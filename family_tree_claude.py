"""
family_tree.py - Kids Running in the Yard
CS 362 / 562 - Assignment 1, Spring 2026

Generated by Claude Code

Simulates a family tree starting from two people born in 1950,
generating children, grandchildren, etc. until no more children
can be generated or until 2120.

Usage:
    python family_tree.py

All CSV data files must be in the current directory:
    life_expectancy.csv          columns: Year, Period life expectancy at birth
    birth_and_marriage_rates.csv columns: decade, birth_rate, marriage_rate
    first_names.csv              columns: decade, gender, name, frequency
    gender_name_probability.csv  columns: decade, gender, probability
    last_names.csv               columns: Decade, Rank, LastName
    rank_to_probability.csv      single line of 30 comma-separated floats
"""

import csv
import math
import random
from collections import defaultdict


# ---------------------------------------------------------------------------
# Person
# ---------------------------------------------------------------------------

class Person:
    """
    Represents a single simulated person in the family tree.

    Attributes are set at construction time via the PersonFactory and
    updated as partners and children are assigned during tree generation.
    """

    def __init__(
        self,
        first_name: str,
        last_name: str,
        year_born: int,
        year_died: int,
        gender: str,
    ):
        self._first_name = first_name
        self._last_name = last_name
        self._year_born = year_born
        self._year_died = year_died
        self._gender = gender    # 'M' or 'F'
        self._partner = None     # Person | None
        self._children = []      # list[Person]

    # -- Accessors -----------------------------------------------------------

    def get_first_name(self) -> str:
        return self._first_name

    def get_last_name(self) -> str:
        return self._last_name

    def get_full_name(self) -> str:
        return f"{self._first_name} {self._last_name}"

    def get_year_born(self) -> int:
        return self._year_born

    def get_year_died(self) -> int:
        return self._year_died

    def get_gender(self) -> str:
        return self._gender

    def get_partner(self):
        return self._partner

    def get_children(self) -> list:
        return list(self._children)

    # -- Mutators ------------------------------------------------------------

    def set_first_name(self, first_name: str):
        self._first_name = first_name

    def set_last_name(self, last_name: str):
        self._last_name = last_name

    def set_partner(self, partner):
        self._partner = partner

    def add_child(self, child):
        self._children.append(child)

    # -- Helpers -------------------------------------------------------------

    def is_alive_in(self, year: int) -> bool:
        """Return True if this person is alive during *year*."""
        return self._year_born <= year <= self._year_died

    def decade_born(self) -> int:
        """Return the decade in which this person was born (e.g. 1950)."""
        return (self._year_born // 10) * 10

    def __repr__(self) -> str:
        return (
            f"Person({self.get_full_name()!r}, born={self._year_born}, "
            f"died={self._year_died}, gender={self._gender!r})"
        )


# ---------------------------------------------------------------------------
# PersonFactory
# ---------------------------------------------------------------------------

class PersonFactory:
    """
    Reads all required CSV data files and creates Person instances.

    Data files expected in the current directory:
        life_expectancy.csv
        first_names.csv
        gender_name_probability.csv
        last_names.csv
        rank_to_probability.csv
        birth_and_marriage_rates.csv
    """

    # Fallback constants used when a file cannot be read or a decade is missing.
    _DEFAULT_LIFE_EXPECTANCY = 78.0
    _DEFAULT_MARRIAGE_RATE = 0.5
    _DEFAULT_BIRTH_RATE = 2.0

    def __init__(self):
        # life_expectancy: year (int) -> float
        # Key is the actual year from the "Year" column.
        self._life_expectancy: dict = {}

        # first_names: decade (int) -> {'M': [(name, freq), ...], 'F': [...]}
        # Populated from columns: decade, gender, name, frequency
        self._first_names: dict = {}

        # gender_name_probability: decade (int) -> {'M': float, 'F': float}
        # Populated from columns: decade, gender, probability
        self._gender_name_prob: dict = {}

        # last_names: decade (int) -> {rank (int): name (str)}
        # Populated from columns: Decade, Rank, LastName
        self._last_names: dict = {}

        # rank_to_probability: list[float], index 0 = rank 1
        # Populated from a single comma-separated line (30 values).
        self._rank_to_probability: list = []

        # birth_and_marriage_rates: decade (int) -> {'birth': float, 'marriage': float}
        self._birth_marriage_rates: dict = {}

        # Cumulative last-name distributions per decade for fast sampling.
        # decade (int) -> [(cumulative_prob, name), ...]
        self._last_name_cumulative: dict = {}

    # -- Public API ----------------------------------------------------------

    def read_files(self):
        """Load all CSV data files from the current directory."""
        self._read_life_expectancy()
        self._read_first_names()
        self._read_gender_name_probability()
        self._read_last_names()
        self._read_rank_to_probability()
        self._read_birth_and_marriage_rates()
        self._build_last_name_cumulatives()

    def get_person(
        self,
        year_born: int,
        last_name: str,
        gender: str = None,
    ) -> Person:
        """
        Create and return a new Person with the given year_born and last_name.

        Args:
            year_born:  The calendar year in which the person is born.
            last_name:  The person's last name.
            gender:     'M' or 'F'; chosen randomly if None.

        Returns:
            A fully initialised Person instance.
        """
        if gender is None:
            gender = random.choice(['M', 'F'])

        first_name = self._pick_first_name(year_born, gender)
        year_died = self._pick_year_died(year_born)

        return Person(
            first_name=first_name,
            last_name=last_name,
            year_born=year_born,
            year_died=year_died,
            gender=gender,
        )

    def get_marriage_rate(self, year_born: int) -> float:
        """Return the probability of marriage for someone born in *year_born*."""
        decade = (year_born // 10) * 10
        rates = self._birth_marriage_rates.get(decade, {})
        return rates.get('marriage', self._DEFAULT_MARRIAGE_RATE)

    def get_birth_rate(self, year_born: int) -> float:
        """Return the expected number of children for someone born in *year_born*."""
        decade = (year_born // 10) * 10
        rates = self._birth_marriage_rates.get(decade, {})
        return rates.get('birth', self._DEFAULT_BIRTH_RATE)

    def get_random_last_name(self, year_born: int) -> str:
        """
        Return a last name sampled according to rank probabilities.

        Selects the name pool for the decade closest to *year_born*,
        falling back to progressively earlier decades if needed.
        """
        decade = (year_born // 10) * 10
        cumulative = self._closest_last_name_cumulative(decade)
        if not cumulative:
            return 'Smith'

        roll = random.random()
        for cumulative_prob, name in cumulative:
            if roll <= cumulative_prob:
                return name
        return cumulative[-1][1]

    # -- Private helpers: parsing --------------------------------------------

    @staticmethod
    def _parse_decade(raw: str) -> int:
        """
        Convert a decade string to an int, tolerating a trailing 's'.

        Examples: '1950' -> 1950, '1950s' -> 1950, ' 1970s ' -> 1970
        """
        return int(raw.strip().rstrip('s'))

    # -- Private helpers: file readers ---------------------------------------

    def _read_life_expectancy(self):
        """
        Reads life_expectancy.csv.

        Expected columns:
            Year                            - calendar year (int)
            Period life expectancy at birth - life expectancy in years (float)
        """
        try:
            with open('life_expectancy.csv', newline='', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    year = int(row['Year'].strip())
                    life_exp = float(row['Period life expectancy at birth'].strip())
                    self._life_expectancy[year] = life_exp
        except FileNotFoundError:
            print("  Warning: life_expectancy.csv not found; using defaults.")
        except (KeyError, ValueError) as error:
            print(f"  Warning: Problem reading life_expectancy.csv: {error}")

    def _read_first_names(self):
        """
        Reads first_names.csv.

        Expected columns:
            decade    - decade of birth (int, e.g. 1950)
            gender    - 'M' or 'F'
            name      - first name string
            frequency - relative frequency / probability (float)
        """
        try:
            with open('first_names.csv', newline='', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    decade = self._parse_decade(row['decade'])
                    gender = row['gender'].strip().upper()
                    name = row['name'].strip()
                    frequency = float(row['frequency'].strip())

                    if decade not in self._first_names:
                        self._first_names[decade] = {'M': [], 'F': []}

                    if gender in ('M', 'F'):
                        self._first_names[decade][gender].append((name, frequency))
        except FileNotFoundError:
            print("  Warning: first_names.csv not found; using defaults.")
        except (KeyError, ValueError) as error:
            print(f"  Warning: Problem reading first_names.csv: {error}")

    def _read_gender_name_probability(self):
        """
        Reads gender_name_probability.csv.

        Expected columns:
            decade      - decade of birth (int)
            gender      - 'M' or 'F'
            probability - probability that a person of this gender receives
                          a traditionally gendered name (float)
        """
        try:
            with open('gender_name_probability.csv', newline='', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    decade = self._parse_decade(row['decade'])
                    gender = row['gender'].strip().upper()
                    probability = float(row['probability'].strip())

                    if decade not in self._gender_name_prob:
                        self._gender_name_prob[decade] = {}
                    self._gender_name_prob[decade][gender] = probability
        except FileNotFoundError:
            print("  Warning: gender_name_probability.csv not found; using defaults.")
        except (KeyError, ValueError) as error:
            print(f"  Warning: Problem reading gender_name_probability.csv: {error}")

    def _read_last_names(self):
        """
        Reads last_names.csv.

        Expected columns:
            Decade   - decade of birth (int)
            Rank     - rank of the last name within that decade (int, 1-30)
            LastName - the last name string
        """
        try:
            with open('last_names.csv', newline='', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    decade = self._parse_decade(row['Decade'])
                    rank = int(row['Rank'].strip())
                    last_name = row['LastName'].strip()

                    if decade not in self._last_names:
                        self._last_names[decade] = {}
                    self._last_names[decade][rank] = last_name
        except FileNotFoundError:
            print("  Warning: last_names.csv not found; using defaults.")
        except (KeyError, ValueError) as error:
            print(f"  Warning: Problem reading last_names.csv: {error}")

    def _read_rank_to_probability(self):
        """
        Reads rank_to_probability.csv.

        The entire file is a single line of 30 comma-separated float values.
        Index 0 corresponds to rank 1, index 1 to rank 2, and so on.
        The values do not necessarily sum to 1.0; they are normalised during
        cumulative distribution construction.
        """
        try:
            with open('rank_to_probability.csv', newline='', encoding='utf-8') as f:
                content = f.read().strip()
                self._rank_to_probability = [
                    float(val.strip()) for val in content.split(',') if val.strip()
                ]
        except FileNotFoundError:
            print("  Warning: rank_to_probability.csv not found; using defaults.")
        except ValueError as error:
            print(f"  Warning: Problem reading rank_to_probability.csv: {error}")

    def _read_birth_and_marriage_rates(self):
        """
        Reads birth_and_marriage_rates.csv.

        Expected columns:
            decade        - decade of birth (int)
            birth_rate    - expected number of children (float)
            marriage_rate - probability of having a partner (float)
        """
        try:
            with open('birth_and_marriage_rates.csv', newline='', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    decade = self._parse_decade(row['decade'])
                    birth_rate = float(row['birth_rate'].strip())
                    marriage_rate = float(row['marriage_rate'].strip())
                    self._birth_marriage_rates[decade] = {
                        'birth': birth_rate,
                        'marriage': marriage_rate,
                    }
        except FileNotFoundError:
            print("  Warning: birth_and_marriage_rates.csv not found; using defaults.")
        except (KeyError, ValueError) as error:
            print(f"  Warning: Problem reading birth_and_marriage_rates.csv: {error}")

    # -- Private helpers: sampling setup -------------------------------------

    def _build_last_name_cumulatives(self):
        """
        Build cumulative distribution lists for last-name sampling, one per decade.

        Pairs each ranked name with its probability from rank_to_probability,
        then normalises so the list can be sampled with a uniform draw on [0, 1).
        """
        for decade, rank_to_name in self._last_names.items():
            pairs = []
            for rank in sorted(rank_to_name.keys()):
                name = rank_to_name[rank]
                # rank_to_probability is 0-indexed; rank 1 -> index 0.
                prob_index = rank - 1
                if prob_index < len(self._rank_to_probability):
                    prob = self._rank_to_probability[prob_index]
                else:
                    prob = 1.0   # fallback equal weight if rank exceeds list
                pairs.append((name, prob))

            if not pairs:
                continue

            total = sum(p for _, p in pairs)
            cumulative = 0.0
            cumulative_list = []
            for name, prob in pairs:
                cumulative += prob / total
                cumulative_list.append((cumulative, name))

            self._last_name_cumulative[decade] = cumulative_list

    def _closest_last_name_cumulative(self, decade: int) -> list:
        """
        Return the cumulative last-name distribution for *decade*, walking
        backwards through decades until one is found, then forward if needed.
        """
        search = decade
        while search >= 1950:
            if search in self._last_name_cumulative:
                return self._last_name_cumulative[search]
            search -= 10

        # Nothing found walking back; try the earliest available decade.
        for d in sorted(self._last_name_cumulative.keys()):
            return self._last_name_cumulative[d]
        return []

    # -- Private helpers: sampling at runtime --------------------------------

    def _pick_year_died(self, year_born: int) -> int:
        """
        Sample a year of death for someone born in *year_born*.

        Looks up life expectancy for the specific birth year, applies a
        uniform +/-10 year random offset, and returns the resulting year.
        """
        life_exp = self._lookup_life_expectancy(year_born)
        offset = random.uniform(-10.0, 10.0)
        return year_born + round(life_exp + offset)

    def _lookup_life_expectancy(self, year_born: int) -> float:
        """
        Return life expectancy for *year_born*, falling back gracefully.

        Checks the exact year first, then expands the search window up to
        5 years in either direction, then returns the global default.
        """
        if year_born in self._life_expectancy:
            return self._life_expectancy[year_born]

        for offset in range(1, 6):
            if year_born - offset in self._life_expectancy:
                return self._life_expectancy[year_born - offset]
            if year_born + offset in self._life_expectancy:
                return self._life_expectancy[year_born + offset]

        return self._DEFAULT_LIFE_EXPECTANCY

    def _pick_first_name(self, year_born: int, gender: str) -> str:
        """
        Sample a first name based on year_born and gender.

        CS 562 feature: respects gender_name_probability to occasionally assign
        a name from the opposite gender's pool when the probability check fails.
        """
        decade = (year_born // 10) * 10

        # Determine which gender pool to sample from.
        gendered_prob = self._get_gender_name_prob(decade, gender)
        if random.random() <= gendered_prob:
            name_gender = gender
        else:
            name_gender = 'F' if gender == 'M' else 'M'

        # Walk backwards through decades until we find name data.
        search_decade = decade
        while search_decade >= 1950:
            pool = self._first_names.get(search_decade, {}).get(name_gender, [])
            if pool:
                return self._weighted_choice(pool)
            search_decade -= 10

        # Walk forward if nothing found going back.
        for d in sorted(self._first_names.keys()):
            pool = self._first_names[d].get(name_gender, [])
            if pool:
                return self._weighted_choice(pool)

        # Ultimate fallback.
        return 'Alex'

    def _get_gender_name_prob(self, decade: int, gender: str) -> float:
        """Return the probability of a gendered name for *gender* in *decade*."""
        decade_data = self._gender_name_prob.get(decade)
        if decade_data is not None:
            return decade_data.get(gender, 1.0)
        return 1.0

    @staticmethod
    def _weighted_choice(name_prob_pairs: list) -> str:
        """
        Choose a name from (name, weight) pairs using weighted random selection.

        Weights need not sum to 1.0; they are treated as relative frequencies.
        """
        total = sum(weight for _, weight in name_prob_pairs)
        roll = random.uniform(0, total)
        cumulative = 0.0
        for name, weight in name_prob_pairs:
            cumulative += weight
            if roll <= cumulative:
                return name
        return name_prob_pairs[-1][0]


# ---------------------------------------------------------------------------
# FamilyTree
# ---------------------------------------------------------------------------

class FamilyTree:
    """
    Drives the generation of a simulated family tree and responds to
    user queries about the resulting population.

    Generation starts with two people born in 1950 and continues until
    no further children can be produced or until the year 2120.
    """

    MAX_YEAR = 2120
    START_YEAR = 1950

    def __init__(self):
        self._factory = PersonFactory()
        self._root_person_a: Person = None
        self._root_person_b: Person = None
        # Every person ever created, in insertion order.
        self._all_people: list = []
        # ids of people who are direct lineage descendants of the root pair.
        self._lineage_ids: set = set()

    # -- Generation ----------------------------------------------------------

    def generate(
        self,
        first_name_a: str = 'Desmond',
        last_name_a: str = 'Jones',
        first_name_b: str = 'Molly',
        last_name_b: str = 'Jones',
    ):
        """
        Build the entire family tree.

        Args:
            first_name_a: First name of the first root person.
            last_name_a:  Last name of the first root person.
            first_name_b: First name of the second root person (partner).
            last_name_b:  Last name of the second root person.
        """
        print("Reading files...")
        self._factory.read_files()

        print("Generating family tree...")

        # Create the two founding people manually to preserve their given names.
        year_died_a = self._factory._pick_year_died(self.START_YEAR)
        year_died_b = self._factory._pick_year_died(self.START_YEAR)

        self._root_person_a = Person(
            first_name=first_name_a,
            last_name=last_name_a,
            year_born=self.START_YEAR,
            year_died=year_died_a,
            gender='M',
        )
        self._root_person_b = Person(
            first_name=first_name_b,
            last_name=last_name_b,
            year_born=self.START_YEAR,
            year_died=year_died_b,
            gender='F',
        )
        self._root_person_a.set_partner(self._root_person_b)
        self._root_person_b.set_partner(self._root_person_a)

        self._all_people.extend([self._root_person_a, self._root_person_b])
        self._lineage_ids.add(id(self._root_person_a))
        self._lineage_ids.add(id(self._root_person_b))

        family_last_name = last_name_a

        # BFS: process one generation at a time.
        # Only the direct-lineage member drives child generation so that each
        # couple produces children exactly once.
        current_generation = [self._root_person_a]
        visited_as_parent = set()

        while current_generation:
            next_generation = []
            for parent in current_generation:
                if id(parent) in visited_as_parent:
                    continue
                visited_as_parent.add(id(parent))

                children = self._generate_children(parent, family_last_name)
                next_generation.extend(children)

            current_generation = next_generation

    def _generate_children(self, parent: Person, family_last_name: str) -> list:
        """
        Attempt to generate children for *parent* (and their partner if any).

        Returns the list of lineage children created so they can seed the
        next generation of the BFS loop.
        """
        partner = parent.get_partner()
        birth_rate = self._factory.get_birth_rate(parent.get_year_born())

        # Child count: birth_rate +/- 1.5, each bound rounded up per spec.
        variation = 1.5
        min_children = max(0, math.ceil(birth_rate - variation))
        max_children = math.ceil(birth_rate + variation)
        num_children = random.randint(min_children, max_children)

        # CS 562: a person without a partner has one fewer child.
        if partner is None:
            num_children = max(0, num_children - 1)

        if num_children == 0:
            return []

        # Children's birth years span parent's age 25 through 45.
        child_year_start = parent.get_year_born() + 25
        child_year_end = parent.get_year_born() + 45

        if child_year_start > self.MAX_YEAR:
            return []

        child_year_end = min(child_year_end, self.MAX_YEAR)

        birth_years = self._distribute_birth_years(
            child_year_start, child_year_end, num_children
        )

        lineage_children = []
        for year_born in birth_years:
            if year_born > self.MAX_YEAR:
                continue

            child_gender = random.choice(['M', 'F'])
            child = self._factory.get_person(
                year_born=year_born,
                last_name=family_last_name,
                gender=child_gender,
            )

            parent.add_child(child)
            if partner is not None:
                partner.add_child(child)

            self._all_people.append(child)
            self._lineage_ids.add(id(child))
            lineage_children.append(child)

            # Does this child get a partner?
            marriage_rate = self._factory.get_marriage_rate(year_born)
            if random.random() <= marriage_rate:
                self._assign_partner(child)

        return lineage_children

    def _assign_partner(self, person: Person):
        """
        Create a new partner for *person* and register them in the tree.

        The partner is born within 10 years of *person* and receives a last
        name sampled from the era-appropriate distribution.
        Per the spec, no name change occurs upon marriage.
        """
        partner_gender = 'F' if person.get_gender() == 'M' else 'M'
        year_offset = random.randint(-10, 10)
        partner_year_born = max(
            self.START_YEAR,
            min(self.MAX_YEAR, person.get_year_born() + year_offset),
        )

        partner_last_name = self._factory.get_random_last_name(partner_year_born)

        partner = self._factory.get_person(
            year_born=partner_year_born,
            last_name=partner_last_name,
            gender=partner_gender,
        )

        person.set_partner(partner)
        partner.set_partner(person)

        self._all_people.append(partner)

    @staticmethod
    def _distribute_birth_years(
        start_year: int,
        end_year: int,
        num_children: int,
    ) -> list:
        """
        Return a list of *num_children* integer birth years distributed
        evenly across [start_year, end_year].
        """
        if num_children == 1:
            return [round((start_year + end_year) / 2)]

        step = (end_year - start_year) / (num_children - 1)
        return [round(start_year + i * step) for i in range(num_children)]

    # -- Queries -------------------------------------------------------------

    def total_people(self) -> int:
        """Return the total number of people in the family tree."""
        return len(self._all_people)

    def people_by_decade(self) -> dict:
        """
        Return a dict mapping decade -> count of people born in that decade.

        Decades are sorted in ascending order.
        """
        counts = defaultdict(int)
        for person in self._all_people:
            decade = (person.get_year_born() // 10) * 10
            counts[decade] += 1
        return dict(sorted(counts.items()))

    def duplicate_names(self) -> list:
        """
        Return a sorted list of full names that appear more than once in the tree.
        """
        name_counts = defaultdict(int)
        for person in self._all_people:
            name_counts[person.get_full_name()] += 1
        return sorted(name for name, count in name_counts.items() if count > 1)

    # -- Interactive CLI -----------------------------------------------------

    def run_interactive(self):
        """Present a simple interactive menu and respond to user queries."""
        menu = (
            "Are you interested in:\n"
            "(T)otal number of people in the tree\n"
            "Total number of people in the tree by (D)ecade\n"
            "(N)ames duplicated\n"
            "> "
        )

        while True:
            try:
                choice = input(menu).strip().upper()
            except (EOFError, KeyboardInterrupt):
                print()
                break

            if choice == 'T':
                print(f"\nThe tree contains {self.total_people()} people total\n")

            elif choice == 'D':
                print()
                for decade, count in self.people_by_decade().items():
                    print(f"{decade}: {count}")
                print()

            elif choice == 'N':
                duplicates = self.duplicate_names()
                print()
                if duplicates:
                    print(f"There are {len(duplicates)} duplicate names in the tree:")
                    for name in duplicates:
                        print(f"  * {name}")
                else:
                    print("There are no duplicate names in the tree.")
                print()

            else:
                print("\nUnrecognised option. Please enter T, D, or N.\n")


# ---------------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------------

def main():
    tree = FamilyTree()
    tree.generate(
        first_name_a='Desmond',
        last_name_a='Jones',
        first_name_b='Molly',
        last_name_b='Jones',
    )
    tree.run_interactive()


if __name__ == '__main__':
    main()